<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Pointeurs, Références &amp; Allocation Dynamique de Mémoire</title>
<!-- 2013-10-19 sam. 17:07 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<link rel="stylesheet" href="../stylesheets/styles.css">
                 <link rel="stylesheet" href="../stylesheets/org-pygments.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
</a><a href="slide_compilation.html">Compilation & Directives de préprocesseur </a><a href="slide_pointeur.html">Pointeurs, Références & Allocation Dynamique de Mémoire </a><a href="slide_specificite_c++.html">Spécificités du C++ (indépendantes de la POO) </a><a href="slide_struct_class.html">Structures & Classes </a><aa>Encapsulation des données </aa><aa>Constructeur & Destructeur de classe </aa><aa>Amitié & Surcharge d'opérateur </aa><aa>Héritage (Partie 1) </aa><aa>Héritage (Partie 2) </aa><aa>Patrons de fonctions et de classes </aa><aa>Introduction à la librairie standard </aa>
                     <hr/>
                     <a href="../../index.html">Retour menu principal</a>
</div>
<div id="content">
<h1 class="title">Pointeurs, Références &amp; Allocation Dynamique de Mémoire</h1><hr/>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Rappels sur les adresses et pointeurs</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>Tout objet manipulé par l&rsquo;ordinateur est stocké en mémoire. Selon la nature de
l&rsquo;objet, l&rsquo;espace en mémoire alloué varie : par ex., entier = 32 ou 64 bits
</li>

<li><b>L&rsquo;adresse</b> est l&rsquo;endroit où se trouve la variable en mémoire. Elle s&rsquo;obtient
via la syntaxe suivante : <code>&amp;NomDeLaVariable</code>
</li>

<li>L&rsquo;adresse n&rsquo;étant ni plus ni moins qu&rsquo;une valeur, on peut donc stocker cette
valeur dans une variable : <b>un pointeur</b> est ainsi un conteneur d&rsquo;adresse
</li>

<li>Déclaration d&rsquo;un pointeur :

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">int</span> <span class="org-variable-name">i</span> = 10;
<span class="org-type">int</span> * <span class="org-variable-name">pt_i</span> = &amp;i;
<span class="org-type">int</span> <span class="org-variable-name">j</span> = *pt_i;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Notion de référence en C++</h2>
<div class="outline-text-2" id="text-2">
<p>
Le C++ introduit la notion de référence afin de faciliter la manipulation des
variables
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Pointeur</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">

<pre class="src src-c++"><span class="org-comment-delimiter">// </span><span class="org-comment">Pointeur</span>
<span class="org-type">int</span> <span class="org-variable-name">i</span> = 10;
<span class="org-type">int</span> * <span class="org-variable-name">pt_i</span> = &amp;i;
(*pt_i)++;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Référence</h3>
<div class="outline-text-3" id="text-2-2">
<div class="org-src-container">

<pre class="src src-c++"><span class="org-comment-delimiter">// </span><span class="org-comment">R&#233;f&#233;rence</span>
<span class="org-type">int</span> <span class="org-variable-name">i</span> = 10;
<span class="org-type">int</span> &amp; <span class="org-variable-name">ref_i</span> = i;
ref_i++;
</pre>
</div>

<ul class="org-ul">
<li>La déclaration d&rsquo;une référence ne crée pas de nouvel objet
</li>

<li>Toute référence doit se référer à un identificateur : <code>int &amp; ref_i;</code> ne
compilera pas. Il est nécessaire <b>d&rsquo;initialiser</b> une référence.
</li>

<li>Une référence pointe toujours vers le même objet, on ne peut pas changer sa
destination.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Références en tant qu&rsquo;arguments de fonctions</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Transmission par adresse</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">void</span> <span class="org-function-name">echange</span> (<span class="org-type">int</span> * <span class="org-variable-name">a</span>, <span class="org-type">int</span> * <span class="org-variable-name">b</span>)
{
  <span class="org-type">int</span> <span class="org-variable-name">c</span> = *a;
  *a = *b;
  *b = c;
}
...
<span class="org-type">int</span> x = 10;
<span class="org-type">int</span> <span class="org-variable-name">y</span> = 20;
echange (&amp;x, &amp;y);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Transmission par référence</h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">void</span> <span class="org-function-name">echange</span> (<span class="org-type">int</span> &amp; <span class="org-variable-name">a</span>, <span class="org-type">int</span> &amp; <span class="org-variable-name">b</span>)
{
  <span class="org-type">int</span> <span class="org-variable-name">c</span> = a;
  a = b;
  b = c;
}
...
<span class="org-type">int</span> x = 10;
<span class="org-type">int</span> <span class="org-variable-name">y</span> = 20;
echange (x, y);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Allocation dynamique de mémoire</h2>
<div class="outline-text-2" id="text-4">
<p>
L&rsquo;allocation dynamique de mémoire est nécessaire dès lors que la taille d&rsquo;un
objet (ou sa nature) n&rsquo;est connue que lors de l&rsquo;exécution du programme. La
déclaration
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">n</span>;
<span class="org-constant">std</span>::cin &gt;&gt; n;
<span class="org-type">double</span> <span class="org-variable-name">tableau</span>[n];
</pre>
</div>

<p>
est rejetée du fait que le compilateur ne connait pas, au préalable, l&rsquo;espace
mémoire nécessaire à l&rsquo;allocation (statique).
</p>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Utilisation des opérateurs <code>new</code> et <code>delete</code></h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>Pour rappel, en langage C, la gestion dynamique de mémoire fait appel aux
fonctions <code>malloc</code> et <code>free</code> (librairie <code>stdlib.h</code>)
</li>

<li>C++ propose deux nouveaux opérateurs :

<ul class="org-ul">
<li><code>new</code> alloue une certaine quantité de mémoire et renvoie un pointeur sur le
début du tableau :
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">n</span>;
<span class="org-constant">std</span>::cin &gt;&gt; n;
<span class="org-type">double</span> * <span class="org-variable-name">tableau</span> = <span class="org-keyword">new</span> <span class="org-type">double</span>[n];
</pre>
</div>
</li>

<li><code>delete[]</code> libère l&rsquo;espace mémoire :
<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">delete</span>[] tableau;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Portée &amp; Durée de vie des variables</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Durée de vie limitée au bloc (ici boucle <code>for</code>)</h3>
<div class="outline-text-3" id="text-6-1">
<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++)
  {
    <span class="org-type">int</span> <span class="org-variable-name">k</span> = 0;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#192; la fin du bloc,</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">destruction de k</span>
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">Durée de vie indépendante du bloc</h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++)
  {
    <span class="org-type">int</span> * <span class="org-variable-name">k</span> = <span class="org-keyword">new</span> <span class="org-type">int</span> (0);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#192; la fin du bloc,</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">k existe en m&#233;moire</span>
  }
</pre>
</div>

<div class="cbox">
<p>
Fuite de mémoire garantie
</p>

</div>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Portée &amp; Durée de vie des variables</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">Durée de vie limitée au bloc (ici boucle <code>for</code>)</h3>
<div class="outline-text-3" id="text-7-1">
<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++)
  {
    <span class="org-type">int</span> <span class="org-variable-name">k</span> = 0;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#192; la fin du bloc,</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">destruction de k</span>
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">Durée de vie indépendante du bloc</h3>
<div class="outline-text-3" id="text-7-2">
<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++)
  {
    <span class="org-type">int</span> * <span class="org-variable-name">k</span> = <span class="org-keyword">new</span> <span class="org-type">int</span> (0);
    <span class="org-keyword">delete</span> k;

  }
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Portée &amp; Durée de vie des variables</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">Allocation sur la pile (“stack”)</h3>
<div class="outline-text-3" id="text-8-1">
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">int</span> * <span class="org-function-name">pointeur_dix</span>()
{
  <span class="org-type">int</span> <span class="org-variable-name">a</span> = 10;
  <span class="org-keyword">return</span> &amp;a;  <span class="org-comment-delimiter">// </span><span class="org-comment">incorrect !</span>
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-type">int</span> * <span class="org-variable-name">pb</span> = pointeur_dix();
  cout &lt;&lt; *pb &lt;&lt; endl;

  <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<div class="cbox">
<p>
Le pointeur retourné contient une adresse obsolète
</p>

</div>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">Allocation sur le tas (“heap”)</h3>
<div class="outline-text-3" id="text-8-2">
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">int</span> * <span class="org-function-name">pointeur_dix</span>()
{
  <span class="org-type">int</span> * <span class="org-variable-name">pa</span> = <span class="org-keyword">new</span> <span class="org-type">int</span>(10);
  <span class="org-keyword">return</span> pa;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-type">int</span> * <span class="org-variable-name">pb</span> = pointeur_dix();
  cout &lt;&lt; *pb &lt;&lt; endl;
  <span class="org-keyword">delete</span> pb;
  <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
